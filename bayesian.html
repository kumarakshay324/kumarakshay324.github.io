    <!DOCTYPE HTML>

<head>
<style>

div.blog_box {
  margin-left: 30%;
  margin-right: 10%;

  background-color: #f5f5ef;
  border: 1px solid #dbdbd5;;
  opacity: 1.0;
  filter: alpha(opacity=100); /* For IE8 and earlier */
}

div.blog_box_sidenav {
  margin-left: 8%;
  margin-right: 10%;
  position: fixed;
  background-color: #f5f5ef;
  border: 1px solid #dbdbd5;
  height: auto;
  width: 350px;
  opacity: 1.0;
  filter: alpha(opacity=100); /* For IE8 and earlier */
}


div.column{
  /*float: right;*/
  margin-right: 0%;
  margin-left: 0%;  
  width: 30%;
  /*width*/: 30%;
  position: fixed;
}

.blog_box_sidenav p:hover{
  color: #140440;
  font-weight: 500;
  /*text-decoration: bold;*/
  /*background-color: #cfc ;*/

}

#myDIV {
}

</style>
</head>

<html>
    <head>
        <title>AKSHAY  KUMAR</title>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <!--[if lte IE 8]><script src="css/ie/html5shiv.js"></script><![endif]-->
        <script src="js/jquery.min.js"></script>
        <script src="js/jquery.dropotron.min.js"></script>
        <script src="js/skel.min.js"></script>
        <script src="js/skel-layers.min.js"></script>
        <script src="js/init.js"></script>
        <noscript>
            <link rel="stylesheet" href="css/skel.css" />
            <link rel="stylesheet" href="css/style.css" />
        </noscript>
        <!--[if lte IE 8]><link rel="stylesheet" href="css/ie/v8.css" /><![endif]-->
    </head>
    <body class="homepage">

        <!-- Header Wrapper -->
            <div class="wrapper style1">
            
            <!-- Header -->

                        
                        <!-- Nav -->
                            <div class="navbox">
                                <ul style="white-space:nowrap;"><br>
                                    <li class="active" style="display:inline; "><a href="portfolio.html" style="text-decoration: none; font-size: 25px; font-weight: 500; color: white">PORTFOLIO &emsp; </a> </li>                                 
                                    <li class="active" style="display:inline; "><a href="images/AKSHAY_KUMAR_RESUME_1PAGE.pdf" target="_blank" style="text-decoration: none; font-size: 25px; font-weight: 500; color: white ">RESUME &emsp;</a></li>

                                    <li class="active" style="display:inline; text-decoration: none;"><a href="index.html" style="text-decoration: none;font-size: 25px; font-weight: 500; color: white">HOME &emsp;</a></li>

                                </ul>
                            </div>
                </div>
                
            <!-- Banner -->
    <!--                <div id="banner">
                        <section class="container">
                            <span style="font-size:80px;color:black"><b>AKSHAY KUMAR</b></span>
                            <span style="font-size:25px;color:black" >  <b>MASTERS IN ROBOTICS ENGINEERING</b> | WORCESTER POLYTECHNIC INSTITUTE </span>
                            <span style="font-size:40px;color:black"> PORTFOLIO </span>

                            </section>
                    </div>
 -->
            </div>          

            <!-- Introduction -->
            <div class="wrapper style6" align="justify" >

            <br>

            <!-- <div class="column"> -->
                <div class="blog_box_sidenav" align="left" >
                    <center>
                    <br>
                    <span style="font-size:25px;text-decoration: none;">LATEST POSTS</span>
                    </center><br>

                    <a style="display:block;font-size:16px;color:black;;text-decoration:none;margin-left:2%;margin-right:10%margin-top:5%" 
                    href="mp_intro.html">
                        <p style="margin-right:2%; margin-left: 2%">  Motion Planning in Robotics</p>
                    </a>

                    <a style="display:block;font-size:16px;color:black;;text-decoration:none;margin-left:2%;margin-right:10%margin-top:5%" 
                    href="ros.html">
                        <p style="margin-right:2%; margin-left: 2%">  Robot Operating System - Command Line Tools</p>
                    </a>

                    <a style="display:block;font-size:16px;color:black;;text-decoration:none;margin-left:2%;margin-right:10%margin-top:5%" 
                    href="sampling.html">
                        <p style="margin-right:2%; margin-left: 2%">  Sampling-based motion planners</p>
                    </a>

                    <a style="display:block;font-size:16px;color:black;;text-decoration:none;margin-left:2%;margin-right:10%margin-top:5%" 
                    href="visual_slam.html">
                        <p style="margin-right:2%; margin-left: 2%">  Visual SLAM - An Introduction</p>
                    </a>

                    <a style="display:block;font-size:16px;color:black;;text-decoration:none;margin-left:2%;margin-right:10%margin-top:5%" 
                    href="slam_intro.html">
                        <p style="margin-right:2%; margin-left: 2%">  Simulataneous Localization and Mapping - An Introduction</p>
                        <br>
                    </a>
                    <br>
                </div>
                
            <!-- </div> -->

            <div class="blog_box" align="justify" >
                    <!-- <center><img src="images/posts.jpg" style="width:1120px;height:706px;margin-left:5%;"></center> -->
                <br>
                    <h2 style="font-size:40px; font-weight: 500;">BAYESIAN METHODS IN ROBOTICS</h2>
                <br>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                The domain of robotics has exploded over the past couple of decades. Robots have evolved from being manipulators employed in manufacturing factories to personal robots, humanoids, mobile robots, robot vacuum cleaners and a lot more. 
                <br><br>
                With all different kinds of robots coming up, considerable stochasticity is introduced due to the sensors for perception, model and measurement inaccuracies and computational uncertainties. Sensors are generally noisy and known to be performing reliably only within a certain expected accuracy. The physical robot models, size measurements, actuator configuration and manufacturing also carry certain imperfections.
                <br><br>
                There are several probabilisitic techniques employed to represent and model these inaccuracies in order to ensure that the final state estimations are closest to ideal. While probabilistic methods try to enhance the accuracy, they eventually introduce stochasicity in the system with approximations and inaccurate assumptions.
                <br><br>

                </p>

                <center>
                    <figure>
                        <img src="images/blogs/bayesian/overview.jpg" style="width:330px;height:247px;">
                    </figure>
                    <br>
                </center>

                <h1 style="text-align:left;margin-left:200px;font-size:20px; ">Introduction</h1>
                <br>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                Probabilistic techiques are largely deployed in robotics for two tasks to tackle uncertainties in state estimation and action ultilization. While state estimation incurrs inaccuracies due to noisy sensors, robot action has uncertain behavior due to imperfect physical model and operational environment inflicted errors( like wheel slippage) thereby necissating the mathematical representation of these tentative uncertaintiies and their inclusion in the system model.
                <br><br>

                Discussed later, certain techniques like the Kalman filters and its variants and the Particle filters are the front-runners of this domain. State estimation applications often also involve a priori sensor-fusion step which also uses these filtering techniques to provide the best perception results.


                <br><br>
                <b style="font-weight: 500"> NOTE: Readers are expected to have basic knowledge about probability, conditional probability, probability distribution functions and their mathematical representations.</b>

               <br><br> 
                <button onclick="myFunction()" class="btn" style="background-color: #FFFFFF;border: none; text-align: center; font-size: 16px;cursor: pointer;width: auto; padding-top: 5px;padding-bottom: : 5px">
                Basic Concepts at a glance - <b style="font-weight: 500">Click to show</b>

                </button>

                <div id="myDIV" style="display: none;">
                <p style="column-width:1000px;margin-left:200px;text-align:justify;">
                <center>
                    <figure>
                        <img src="images/blogs/bayesian/prob_basics.png" style="width:700px;height:500px;">
                    </figure>
                    <br>
                </center>
                </p>
                </div>

                <script>
                function myFunction() {
                  var x = document.getElementById("myDIV");
                  if (x.style.display === "none") {
                    x.style.display = "block";
                  } else {
                    x.style.display = "none";
                  }
                }
                </script>

                </p>

                <h1 style="text-align:left;margin-left:200px;font-size:20px; ">Bayesian Terminology and Concepts</h1>
                <br>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                Probabilistic theory can get confounding when dealing with several jargons. Moreover, the complete foundation of these probabilistic techniques is built upon just a few mathematical concepts and assumptions, discussed here.
                <br><br>
                <i>For all discussions further;  <b style="font-weight: 500">x</b> = state, <b style="font-weight: 500">z</b> = observation,  <b style="font-weight: 500">u</b> = action and <b style="font-weight: 500">X</b> = a random variable</i>
                </p>

                <ul style="column-width:1000px;margin-left:300px;margin-right:200px;text-align:justify;list-style-type:disc;">
                    <li> <b style="font-weight: 500">P( z | X = x<sub>i</sub> )</b>  is causal (given that the state <b style="font-weight: 500">x</b> is known, what could the observation <b style="font-weight: 500">z</b> predict  ) while <b style="font-weight: 500">P( X = x<sub>i</sub> | z )</b> is diagnostic (given that the observation <b style="font-weight: 500">z</b> is known, what would the actual state <b style="font-weight: 500">x</b> be).
                        <br><br>
                        Causal systems are easier to obtain because it represents the reliability of a sensor (that obtains the observation <b style="font-weight: 500">z</b>) which can be obtained manually.
                        <br><br>
                    The Bayes filter gives us <br>
                    <center> <b style="font-weight: 500">
                        P( X = x<sub>i</sub> | z ) = P( z | X = x<sub>i</sub> ) * P(X = x<sub>i</sub>) / P(z)
                    </b>
                    </center>
                    <br>
                    <li>
                        Normalization of the Bayes Filter gives
                        <center>
                            <b style="font-weight: 500">
                    P( x | y ) = P( y | x ) * P( x ) / P( y ) = &#951 P( y | x ) * P( x )
                    <br>
                    where &#951  = P( y )<sup>-1</sup> = 1 / ( &#931 P( y | x) P( x ))

                            </b>
                        </center>
                    </li><br>
                    <li>
                        Markov assumption says current observation <b style="font-weight: 500">z<sub>t</sub></b> at timestamp <b style="font-weight: 500">t</b> is independent of all prior observations <b style="font-weight: 500">z<sub>1:t-1</sub></b> and all prior input signals <b style="font-weight: 500">u<sub>1:t</sub></b> given the state <b style="font-weight: 500">x<sub>t</sub></b> is available. 

                        <br><br>                            
                        Markov assumption also states that the current state <b style="font-weight: 500">x<sub>t</sub></b> at timestamp <b style="font-weight: 500">t</b> is independent of all prior observations <b style="font-weight: 500">z<sub>1:t-1</sub></b> given the state at the previous timestamp <b style="font-weight: 500">x<sub>t-1</sub></b> and input signal at the current timestamp u<sub>t</sub></b> are given.
                    </li> <br>
                    <li>
                        A sensor model is the mathematical representation of the belief in the accuracy of a sensor's estimate of the parameter. The action model is the mathematical representation of the belief in the ability of the inputs given to the robot to actually drive the robot to the expected(mathematicall derived) final configuration.
                        <br><br>
                        For instance, in a mobile robot; the range-measurement sensor model should state the probability with which the sensor measures the distance accurately and could be affected by noise and operational limitations of the sensor. For the action model, it would be the ability of the mobile robot to move the amount of distance that it is expected to, when fed with a particular velocity/acceleration/jerk. 
                    </li>
                </ul>

                <br>
                <h1 style="text-align:left;margin-left:200px;font-size:20px ">State Estimation</h1>                
                <br>
                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                For a robot, its state could comprise of any number of parameters defining its configuration. It could be the position(x,y,z) and orientation(qw,qx,qy,qz) for the end-effector of a manipulator or the GPS coordinates of a drone or the joint angles of the legs of a biped robot.
                <br><br>
                <b style="font-weight: 500">For the sake of simplicity, this artcile refers to the pose of a mobile robot - position (x, y) and orientation (&#952) of the heading as the state being determined. In mobile robotics terminology, this is localization - the process of determining the location of the robot in the world given the actions that it takes and the perception model derived observations.
                </b>
                </p>

                <center>
                    <figure>
                        <img src="images/blogs/bayesian/localization.png" style="width:450px;height:400px;">
                        <figcaption>Visual Representation of Robot Localization </figcaption>
                    </figure>
                    <br><br>
                </center>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">
                    For a mobile robot, it can be intuitively understood that the current best estimate of its pose will be dependent upon how well does the sensor model observe its pose and how well does the robot model implement the action on the robot.
                    <br><br>
                    Thus, the probabilistic representation of the robot's pose, i.e. the localization process should be dependent on the sensor model and the action model.

                    <center style="column-width:1000px;margin-left:200px;margin-right:200px;">
                    <b style="font-weight: 500">
                    Sensor model =  P(z<sub>t</sub> | x<sub>t</sub> ) 
                    </b>
                    <br>
                    Inference: sensor observation at timestampt t is only dependent upon the state at timestamp t
                    <br><br>
                    <b style="font-weight: 500">
                    Action model =  P(x<sub>t</sub> | u<sub>t</sub>, x<sub>t-1</sub> )
                    </b>
                    <br>
                    Inference: State at timestamp t is dependent upon the action taken at timestamp t and state at timestamp (t-1)
                    </b>
                    </center>
                </p>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                Probabilistic Roadmap planning is a construct and multi-query motion planning technique proposed first in 1996. It has two steps - a learning phase (generally preprocessed ) and a query phase. The learning phase does the bulk work of understanding the workspace upfront before the second query phase which merely searches through the representation derived in the prior phase to provide a final solution.
                <br><br>



                <center>
                    <b style="font-weight: 600"><u>LEARNING PHASE</u></b> </p>
                </center>
                <p style="column-width:1000px;margin-left:250px;margin-right:200px;text-align:justify;">

                In the <b style="font-weight: 500">learning phase</b> - several samples are drawn from the workspace and connected to ones nearby, thus creating a roadmap between them all, including the start and desired end point. It lays the foundation for connectivity in the in the C<sub>free</sub>. The learning phase has a <b style="font-weight: 500">construction phase</b> and an <b style="font-weight: 500">expansion phase</b>.
                <br><br>
                The construction phase creates the roadmap and the expansion phase attempts at filling the gaps in connectivity between sections of the workspace positioned uniquely, involving additional sampling and connections thereafter between the disconnected components.

                <b  style="font-weight: 500">
                    <center>Learning Phase - Part I - Construction</center>
                    <br>
                </b>

                    <ul style="column-width:1000px;margin-left:300px;margin-right:200px;text-align:justify;list-style-type:disc;">
                        <li>Initialize the graph <b>G(V,E)</b> where <b>V</b> is the collection of nodes (the sampled points, also called milestones) and <b>E</b> is the collection of edges connecting certain nodes</li><br>
                        <li>
                            Randomly sample definite number of configurations, ensure they are collision free samples and add them to <b>V</b> 
                            <br><br>
                            Extracting random samples still is still tricky. Ideally, the samples should be distributed across the complete <b>C<sub>space</sub></b>. Usually, uniform probability distribution over the particular dimension is used to ensure a map with good connectivity.
                        </li><br>
                        <li>
                            Attempt connecting each node in V to certain, k number of other nodes and find a path between them using a local planner. The local planner can either be a fast one that tries connecting directly between the samples or a slow non-deterministic one. 

                            <br><br>                            
                            If the connection is established between two nodes (the path being collision-free), the edge <b>E(node<sub>1</sub>, node<sub>2</sub>)</b> is saved. Generally, connectivity between the nodes is inversely proportional to the distance between them.
                        </li> <br>
                    </ul>

                        <center>
                            <figure>
                                <img src="images/blogs/sampling_mp/prm_exp.png" style="width:580px;height:290px;">
                                <figcaption>Figure 6 - Missing Connections during the Construction Phase </figcaption>
                            </figure>
                            <br><br>
                        </center>

                <b  style="font-weight: 500">
                    <center>Learning Phase - Part II - Expansion</center>
                </b>
                    <br>
                    <ul style="column-width:1000px;margin-left:300px;margin-right:200px;text-align:justify;list-style-type:disc;">
                        <li>
                            Certain nodes are selected for expansion, i.e. more connectivity is attempted from those nodes.
                        </li><br>
                        <li>
                            Each node <b>n</b> in <b>V</b> is assigned a weight <b>w(n)</b>. It is an estimate of proximity of the node to difficult regions like the narrow passage shown above.
                            <br><br>
                            Weights are normalized such that <b>&#931w(n) = 1</b> and the ones with highest weights(like the red point in Figure 6) are selected to expand. If a node has poor connectivity, it should have a higher weight <b>w(n)</b>.

                        </li><br>
                        <li>
                            Estimation of weights for the node <b>n</b> can use different standards. It could be counting a certain number of nodes from <b>V</b> lying within a known distance radius of the node <b>n</b> or checking distances between a node <b>n</b> and its nearest connected nodes.
                            <br><br>
                            For the former, lower the number of connected nodes, higher the chances of the node being deserted and has poor connectivity; while for the latter, the larger distance between the node and its connected nodes, the higher connectivity gap  or disconnection exists in that region.
                            <br><br>
                            The results from local planner connection attempts for a particular node can also be used to understand the connectivity of the same. High failure cases can be intuitively be understood as the node connected poorly or being completely disconnected. Such nodes are awarded higher weights and more connection is attempted around these. 

                        </li><br>
                        <li>
                            For the local planner,
                            <br> 
                            <center>
                                <i>Failure Ratio, <b>f<sub>r</sub>(n) = f(n) / t(n) + 1 </b></i>
                            </center>

                            where <b>f</b> is the number of failures during attempted <b>t</b> number of connections. 
                            <br>
                            Finally, for one node, the  weight <br>
                            <center>
                                <b>w(n)</b> = <b>f<sub>r</sub>(n) / &#931 f<sub>r</sub>(a)</b>
                            </center>
                            <br>    
                            where <b>f<sub>r</sub>(a)</b> is for every node <b>a</b> in <b>V</b>  
                        </li><br>
                        <li>
                            Finally, after the normalized weights are obtained, nodes with weights over a certain threshold are selected are expansions
                        </li><br>
                        <li>
                            For a selected node <b>n</b>, at a pre-defined distance from it and in a random direction; a new node <b>n<sub>new</sub></b> is generated.
                            <ul style="column-width:1000px;margin-left:50px;text-align:justify;list-style-type:circle;">
                                <li>If <b>n<sub>new</sub></b> lies in <b>C<sub>free</sub></b> and the edge <b>e</b> connecting them also does, then <b>n<sub>new</sub></b> is added to <b>V</b> and the edge <b>e(n, n<sub>new</sub>)</b> is saved in <b>E</b>.
                                </li>
                                <li> If not, the same attempt for a new node <b>n<sub>new</sub></b> is attempted in another random direction.
                                </li>
                            </ul> 
                        </li>
                        <li>
                            At the end of expansion phase, more connectivity and ideally in inaccessible areas of the map, is obtained.
                        </li><br>                        
                    </ul>

                            <center>
                                <figure>
                                    <img src="images/blogs/sampling_mp/expansion.jpg" style="width:580px;height:290px;">
                                    <figcaption>Figure 7 - Enhanced Connectivity in Expansion Phase </figcaption>
                                </figure>
                                <br>
                            </center>                                        
                </p>

                <center>
                    <b style="font-weight: 600"><u>QUERY PHASE</u></b> </p>
                </center>

                <p style="column-width:1000px;margin-left:250px;margin-right:200px;text-align:justify;">

                    The <b style="font-weight: 500">Query Phase</b> is a relatively easier phase with all the bulk computational processing already done. It accepts a start <b>s</b> and a goal <b>g</b> configuration and attempts to find a path between them.
                    <br><br>
                     Ideally, a path exists in the roadmap connecting the two and the query returns that path (a collection of all intermediate edges passing through other intermittent nodes that eventually establish connectivity between <b>s</b> and <b>g</b>)  

                <br><br>

                    <ul style="column-width:1000px;margin-left:300px;margin-right:200px;text-align:justify;list-style-type:disc;">
                        <li>
                            If the start <b>s</b> and goal <b>g</b> are points not already sampled and existing in the roadmap <b>R</b>, they are connected to the closest nodes in <b>R</b>, through paths <b>P<sub>s</sub></b> and <b>P<sub>g</sub></b>. If these two connections are not possible, the complete query fails for path the between <b>s</b> and <b>g</b> does not exist.
                        </li><br>
                        <li>
                            Starting with <b>s</b>, new nodes with increasing distance from it are added to the path <b>P</b> being derived, using a local planner again.
                        </li><br>
                        <li>
                            Finally, the complete path connecting is given as <b>P<sub>complete</sub></b> =  <b>P<sub>s</sub></b> + <b>P</b> + <b>P<sub>g</sub></b>
                        </li> <br>
                    </ul>

                </p>

                <p style="column-width:1000px;margin-left:250px;margin-right:200px;text-align:justify;">
                    Given that there are several parameters, assumptions and challenges like number of samples, number of retries, sampling techniques, local planners, narrow passages in the map and sampling near obstacles; there are chances of the query failing.
                    <br><br>
                     However, limited connectivity in the roadmap and all problems are attempted to be resolved by retrying Learning Phase, exhaustively running Expansion Phase and concurrently operational Learning & Query Phases.

                    <br><br>
                    There are several enhanced PRM techniques like Obstacle-Based PRM, Medial-Axis PRM and Simplified PRM among others used to address specific challenges for sampling near obstacles, sampling in narrow passages and sampling problems in general. 
                </p>

                <p style="column-width:1000px;margin-left:250px;margin-right:200px;text-align:justify;"> <b>RAPIDLY-EXPLORING RANDOM TREES</b></p>

                <p style="column-width:1000px;margin-left:250px;margin-right:200px;text-align:justify;">

                Rapidly-Exploring Random Trees (RRT) is the most famous family of sampling-based  motion planning algorithms. While PRMs or Potential Field methods are probabilistic in nature and have limitations with substantial effect on planning, RRTs can solve better for lots of constraints.    
                 <br><br>
                The algorithm basically starts at some location in the map and starts branching out in random directions, sampling new points at pre-defined distance from the initial location. After an edge is established between the initial point and the new sampled point, the latter becomes the initial location for the next step of branching out.   
                <br><br>
                Using appropriate values for step size, number of sampels to drawn, initial point and other parameters, a densely connected tree-structured map is promised.

                </p>

                <center>
                    <b style="font-weight: 600"><u>The Algorithm</u></b> </p>
                </center>

                    <ul style="column-width:1000px;margin-left:300px;margin-right:200px;text-align:justify;list-style-type:disc;">

                        <li>
                            Setup the planner with an initial point <b>x<sub>init</sub></b>, the number of points to be sampled <b>k</b> and the step size <b>&#916<sub>t</sub></b>
                        </li><br>
                        <li>                                                       
                            Initialze a tree <b>&#964</b> that shall contain sampled points, with the initial point <b>x<sub>init</sub></b>
                        </li><br>
                        <li>                           
                            Sample a random point <b>x<sub>rand</sub></b> in the workspace
                        </li><br>
                        <li>                           
                            Obtain the nearest neighbor <b>x<sub>near</sub></b> for the <b>x<sub>rand</sub></b> point from the list of points in <b>&#964</b>
                        </li><br>
                        <li>                           
                            Finally, derive a new point <b>x<sub>new</sub></b> and add it to the tree <b>&#964</b> <br>
                            <i>
                                If <b>distance(x<sub>near</sub></b> , <b>x<sub>rand</sub></b> )</b> is less than step size <b>&#916</b>, then <b>x<sub>new</sub></b> = <b>x<sub>near</sub></b>, else <b>x<sub>new</sub></b> is an intermittent point at a distance of <b>&#916</b> from <b>x<sub>near</sub></b> on the line joining <b>x<sub>near</sub></b> and <b>x<sub>rand</sub></b>.
                            </i>
                        </li><br>
                        <li>
                            The edge <b>e(x<sub>near</sub>, x<sub>new</sub>)</b> is an intermittent path in the tree. Several short paths like these ensure connectivity throughout the map
                        </li><br>
                        <li>
                            If the <b>distance(x<sub>new</sub></b>, <b>x<sub>goal</sub>)</b> is less than the step size <b>&#916</b>, the edge <b>e(x<sub>near</sub>, x<sub>new</sub>)</b> is also stored as a path.
                        </li><br>    
                        <li>
                            Final points in <b>&#964</b> are all possible nodes in the map. <br>                            
                        </li><br>
                    </ul>

                <center>
                    <b style="font-weight: 600"><u>Subtle Features of RRTs</u></b> </p>
                </center>


                    <ul style="column-width:1000px;margin-left:300px;margin-right:200px;text-align:justify;list-style-type:disc;">
                        <li>
                            RRTs can solve for holonomic, nonholonomic and kinodynamic situations. Kinodynamic planning is when the robot planning is done within the kinematic constraints of velocity, acceleration, joint angle limits and obstacle avoidance.
                        </li><br>
                        <li>                            
                            In cases where a naive random tree is generated out of incrementally selecting random points and adding it to the vertices, it heavily explores an already clustered environment.
                        </li><br>
                        <li>
                            Even a random walk shows bias towards already explored places. Since, RRT is generated by selection of the nearest vertex, it ensures unexplored sections of the configuratio space are considerably seen.
                        </li><br>
                        <li>                             
                            RRTs do not form closed loops and thus, the map it decides is near optimal if not completely optimal. 
                        </li><br>
                        <li>
                            Initially, the vertices are not uniformly distributed but the probability of a random point lying withing the step size delta_t of a vertex of a tree(the x_near point) eventually tends to 1
                        </li><br>
                        <li>                            
                            If the random points generated are uniform, then such a setting would be independent of x_init and would defy the purpose of RRTs. 
                        </li><br>
                        <li>
                            Also, if the points are sampled from some pre-defined PDF (probability distribution function), then the RRT vertices would be accordingly. Such a setup can be used to device biased schemes which might be difficult and time taking to converge.
                        </li><br>
                        <li>
                            Ideal performance of a RRT is defined by the distance parameter <b>&#916</b> - which determines the shortest distance between two states. 
                        </li><br>
                        <li>
                            For constrained path planning, the optimal path would be the one with the least cost function and the cost function would be its metric.
                        </li><br>
                        <li>
                            Probabilistic approach creates too many extra edges and also depends upon k-nearest neighbors as compared to a single neihbor for the RRTs. 
                        </li><br>
                        <li>
                            RRT is probabilistically complete and relatively easier to implement.
                        </li><br>
                        <li>                            
                            RRT maps always remain connected even in cases of less vertices and can be applied to a broad range of planning algorithms.
                        </li><br>
                    </ul>

                <p style="column-width:1000px;margin-left:250px;margin-right:200px;text-align:justify;">
                    Given the advantages of the basic RRT algorithm, several enhancements like Bidirectional RRT, RRT*, RRT-Connect and RRT*-Smart among others have been used to optimize the solutions and get better performance.
                    <br><br>

                    Recently, lots of efforts have been put into using RRT with better hardware (like GPUs), using other search algorithms in conjunction and hand-crafted optimizations for certain operational constraints/desires have fetched roboticists enhanced performance and usage. 
                </p>

            </div>
            </div>

            <p style="column-width:1000px;margin-left:550px;margin-right:200px;text-align:center;font-size: 22px;font-weight: 500;color: red">
                <i>
                IF YOU LIKED THE ARTICLE, DON'T FORGET TO LEAVE A REACTION OR A COMMENT!                         
                </i>
            </p>

            <div id="disqus_thread" style="column-width: 1000px;margin-left: 570px;margin-right: 200px;"></div>
            <script>

            /**
            *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
            *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

            var disqus_config = function () {
            this.page.url = "http://kumarakshay.me/bayesian.html";  // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = 150; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
            };

            (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://kumarakshay-me.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
            })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

    
        <!-- Section One -->
            <div class="wrapper style2">

                <p style="margin-bottom:0;padding-bottom:0;"><hr width="50%"><center>Copyright @Akshay Kumar | Last Updated on 05/25/2019</center></p> 

            </div>
<div align=center><a href='https://www.counter12.com'><img src='https://www.counter12.com/img-y9Z8xYWb7W273YW2-50.gif' border='0' alt='counter'></a><script type='text/javascript' src='https://www.counter12.com/ad.js?id=y9Z8xYWb7W273YW2'></script></div>

            <div id="mySidenav" class="sidenav">
<!--              <a href="#" id="about">About
 -->

                     <a href="mailto:singhakshay324@gmail.com" target="_blank" id="gmail1"><img src="images/contacts/gmail.png" style="width:50px;height:50px;"> </a>

                     <a href="mailto:akumar5@wpi.edu" target="_blank" id="gmail2"><img src="images/contacts/outlook.png" style="width:50px;height:50px;"></a>

                    <a href="http://in.linkedin.com/in/kumarakshay324" target="_blank" id="linkedin"><img src="images/contacts/linkedin.png" style="width:50px;height:50px;;"></a></center>

                     <a href="https://github.com/kumar-akshay324" target="_blank" id="github"><img src="images/contacts/github.png" style="width:50px;height:50px;"></a>

                    <a href=" http://www.quora.com/profile/Akshay-Singh-66" target="_blank" id="quora"><img src="images/contacts/quora.png" style="width:50px;height:50px;;"></a>

                    <a href="http://www.facebook.com/singhakshay324" target="_blank" id="social"><img src="images/contacts/fb.png" style="width:50px;height:50px;;"></a>


<!--              <a href="#" id="blog">Blog</a>
              <a href="#" id="projects">Projects</a>
              <a href="#" id="contact">Contact</a>
 -->            </div>
    </body>
</html>
