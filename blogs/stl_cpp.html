    <!DOCTYPE HTML>

<head>
<style>

div.blog_box {
  margin-left: 30%;
  margin-right: 10%;

  background-color: #f5f5ef;
  /*border: 1px black;*/
  opacity: 1.0;
  filter: alpha(opacity=100); /* For IE8 and earlier */
}

div.column{
  /*float: right;*/
  margin-right: 0%;
  width: 30%;
  position: fixed;
}

code { 
  font-family: monospace;
}

</style>
</head>

<html>
    <head>
        <title>AKSHAY  KUMAR</title>
        <link rel="icon" href="images/profile.jpg">
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <!--[if lte IE 8]><script src="css/ie/html5shiv.js"></script><![endif]-->
        <script src="../js/jquery.min.js"></script>
        <script src="../js/jquery.dropotron.min.js"></script>
        <script src="../js/skel.min.js"></script>
        <script src="../js/skel-layers.min.js"></script>
        <script src="../js/init.js"></script>
        <noscript>
            <link rel="stylesheet" type="text/css" href="${pageContext.request.contextPath}/css/skel.css" />
            <link rel="stylesheet" type="text/css" href="${pageContext.request.contextPath}/css/style.css" />
        </noscript>
        <!--[if lte IE 8]><link rel="stylesheet" href="css/ie/v8.css" /><![endif]-->
    </head>
    <body class="homepage">

        <!-- Header Wrapper -->
            <div class="wrapper style1">
            
            <!-- Header -->

                        
                        <!-- Nav -->
                            <div class="navbox">
                                <ul style="white-space:nowrap;margin-top: 10px">
                                    <li class="active" style="display:inline; "><a href="portfolio.html" style="text-decoration: none; font-size: 25px; font-weight: 500; color: white">PORTFOLIO &emsp; </a> </li>                                 
                                    <li class="active" style="display:inline; "><a href="images/AKSHAY_KUMAR_RESUME_1PAGE.pdf" target="_blank" style="text-decoration: none; font-size: 25px; font-weight: 500; color: white ">RESUME &emsp;</a></li>

                                    <li class="active" style="display:inline; text-decoration: none;"><a href="index.html" style="text-decoration: none;font-size: 25px; font-weight: 500; color: white">HOME &emsp;</a></li>

                                </ul>
                            </div>
                </div>
                
            </div>          

            <!-- Introduction -->
            <div class="wrapper style6" align="justify" >

            <br>

            <div class="column">
                <div class="blog_box" align="justify" >
                    <center>
                    <br>
                    <p style="font-size:20px;">LATEST POSTS</p>
                    </center>

                    <a style="display:block;font-size:13px;color:black;;text-decoration:none;margin-left:2%;margin-right:10%margin-top:5%" 
                    href="slam_intro.html">
                        <p style="margin-right:5%">&#128462 Simulataneous Localization and Mapping - An Introduction</p>
                    </a>

                    <a style="display:block;font-size:13px;color:black;;text-decoration:none;margin-left:2%;margin-right:10%margin-top:5%" 
                    href="coverage.html">
                        <p style="margin-right:5%">&#128462 Coverage Problems in Mobile Robotics</p>
                    </a>

                    <a style="display:block;font-size:13px;color:black;;text-decoration:none;margin-left:2%;margin-right:10%margin-top:5%" 
                    href="mp_intro.html">
                        <p style="margin-right:5%">&#128462 Motion Planning in Robotics - Yet Another Introduction!</p>
                        <br>
                    </a>
                    <br>
                </div>
                
            </div>

            <div class="blog_box" align="justify" >
                    <!-- <center><img src="images/posts.jpg" style="width:1120px;height:706px;margin-left:5%;"></center> -->
                <br>
                    <h2 style="font-size:40px">STL Algorithms in C++</h2>
                <br>


                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                    The Standard Template Library in C++ is a large native library in C++ that provides in-built data structures and algorithms. It is a collection of containers, iterations and algorithms. STL is templated and thus supports multiple variants of data types like vectors, lists, deque, arrays, heaps and sets. 

                    This article talks about the general algorithms for searching, sorting and queries applicable to these containers.
                </p>

                <center>
                    <figure>
                        <img src="images/stl_overview.png" style="width:622px;height:390px;">
                        <figcaption>STL Overview</figcaption>
                    </figure>


                    <br><br>
                </center>
                <h1 style="text-align:left;margin-left:200px;font-size:20px; ">Introduction</h1>
                <br>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                This list of algorithms is not exhaustive yet contains the most common and# useful C++ native algorithms in the STL library. Any of these algorithms can be written again though the efficiency of the same would atmost be comparable to the same available in the STL libraries.

                <br><br>

                <b>NOTE: </b> <br>

                    <code>vector.begin(), vector.end()</code> can also be replaced by <code>std::begin(vector)</code> and <code>std::end(vector)</code> respectively as <code>std::begin(vector)</code> was only introduced in C++ 11 to allow easy coding for generic templated structures that support C-style arrays (that do not have methods like <code>.begin()</code>) as well as STL containers. 

                <h1 style="text-align:left;margin-left:200px;font-size:20px ">HEAPS</h1>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                    Heaps are special tree-based data structures following one particular heap condition: node values down the tree are sctricty ascending(min heap) or strictly descending (max heap), i.e. parent-child relationship is monotonic. A heap is not completely sorted but partially ordered binary tree and thus knowing the priority for the element, a heap can serve for efficient data manipulation and accessibility.
                    <br><br>
                    The Standard Template Library in C++ allows for a heap data structure and which has a priority queue as the base container. The algorithms provide the functions necessary to use the features of a heap.

                </p>

                <center>
                    <figure>
                        <img src="images/heap.png" style="width:622px;height:390px;">
                        <figcaption>Data Structure - Heaps</figcaption>
                    </figure>

                    <br><br>
                </center>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;"> <i> <b>Algorithms for Heaps</b></i> </p>
                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">
                        
                    <b>&#8658</b> Create a heap from vector of numbers <br>
                    <code> 
                        std::make_heap(vector.begin(), vector.end())
                    </code><br><br>

                    <b>&#8658</b> Add contents to a heap (it handles the pushing of numbers and arranges them in the heap based on the comparison) <br>
                    <code> 
                        std::push_heap(vector.begin(), vector.end())
                    </code><br><br>


                    <b>&#8658</b> Pop out the highest number
                    <br>
                    <code> 
                        std::pop_heap(vector.begin(), vector.end())
                    </code><br><br>

                    <b>&#8658</b> Reverse the order of the heap (Applicable to other containers as well )<br>
                    <code> 
                        std::reverse(vector.begin(), vector.end())
                    </code><br><br>


                    <b>&#8658</b> Sort the elements of the heap in ascending order and the range is no longer a heap
                    <br>
                    <code> 
                        std::sort_heap(vector.begin(), vector.end())
                    </code><br><br>

                </p> 

                <h1 style="text-align:left;margin-left:200px;font-size:20px ">SORTING</h1>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                    Sorting the information stored in containers based on conditions is one of the most common things to do while dealing with any data. As simple as ranking students on the scores obtained means first arranging the scores in descending order.
                    <br><br>
                    The Standard Template Library in C++ provides in-built implementations for different kinds of sorting operations. The templated nature of the library allows for the same algorithm to be applicable to all kinds of containers offered by C++.

                </p>

                <center>
                    <figure>
                        <img src="images/sorting.png" style="width:622px;height:390px;">
                        <figcaption>Sorting</figcaption>
                    </figure>

                    <br><br>
                </center>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;"> <i> <b>Algorithms for Sorting</b></i> </p>
                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                    <b>&#8658</b> Sorting of numbers in ascending order. If function is provided then it is used for sorting comparison. If fucntion returns <b>true</b>, then first element ordered before second.<br>
                    <code> 
                        std::sort(vector.begin(), vector.end(), function)
                    </code><br><br>


                    <b>&#8658</b> Sorting of numbers in ascending order. If function is provided then it is used for sorting comparison. If fucntion returns <b>true</b>, then first element ordered before second.
                    <br>
                    <b>Different from <code><it>sort</it></code> because it preserves the order of elements that have the same values, thus called stable.</b>
                    <br>
                    <code> 
                        std::stable_sort(vector.begin(), vector.end(), function)
                    </code><br><br>


                    <b>&#8658</b> Sorting of numbers in the range [first, last) only for specified middle values. If function provided then it is used for sorting comparison. If fucntion returns **true**, then first element ordered before second.<br>
                    <code> 
                        std::partial_sort(vector.begin(), middle, vector.end())
                    </code><br><br>


                    <b>&#8658</b> Rearrange the list such that the nth element has the value that should have existed there if the list was sorted. The nth element has all preceding elements lesser than it and succeeding elements larger than it.
                    <br>
                    <code> 
                        std::nth_element(vector.begin(), nth_element, vector.end())
                    </code><br><br>

                </p> 

                <h1 style="text-align:left;margin-left:200px;font-size:20px ">PERMUTATIONS</h1>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                    Elements of a container are required to be shuffled in different orders as per need.
                    <br><br>
                    The Standard Template Library in C++ provides in-built implementations for different kinds of permutation/re-arranging operations. The templated nature of the library allows for the same algorithm to be applicable to all kinds of containers offered by C++.

                </p>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;"> <i> <b>Algorithms for Permutations</b></i> </p>
                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                    <b>&#8658</b> Reverse the order of elements in the container<br>
                    <code> 
                        std::reverse(vector.begin(), vector.end())
                    </code><br><br>

                    <b>&#8658</b> Create a new copy of the container to a <code><b>new_vector</b></code> with reversed order of elements<br>
                    <code> 
                        std::reverse_copy(vector.begin(), vector.end(), new_vector.begin())
                    </code><br><br>

                    <b>&#8658</b> Rotate the container about the middle element such that the middle element becomes the first element of the new rotated vector. Possible applications are found in insertion sort or order reshuffling<br>
                    <code>
                        std::rotate(vector.begin(), vector.middle(), vector.end())
                    </code><br><br>

                    <b>&#8658</b> Reshuffle the elements of the container based on using the <code>std::rand</code> as the random seed generator function<br>
                    <code>
                        std::random_shuffle(vector.begin(), vector.end())
                    </code><br><br>

                    <b>&#8658</b> Reshuffle the elements of the container based on a seed obtained via URBG (Uniform Random Bit Generator). More efficient that the <code>std::random_shuffle</code><br>
                    <code>
                        std::shuffle(vector.begin(), vector.end(), random_number_generator)
                    </code><br><br>

                    <b>&#8658</b> Rearrange the elements of the container into a permutation higher up in the lexicographical order.<br>
                    <code>
                        std::next_premutation(vector.begin(), vector.end())
                    </code><br><br>

                    <b>&#8658</b> Rearrange the elements of the container into a permutation lower down in the lexicographical order.<br>
                    <code>
                        std::prev_premutation(vector.begin(), vector.end())
                    </code><br><br>

                </p> 


                <h1 style="text-align:left;margin-left:200px;font-size:20px ">QUERYING RANGES</h1>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                    Several queries about the features of containers are made, either for one single container or multiple ones.
                    <br><br>
                    The Standard Template Library in C++ provides in-built implementations for several such querying operations. The templated nature of the library allows for the same algorithm to be applicable to all kinds of containers offered by C++.

                </p>

                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;"> <i> <b>Algorithms for Querying Containers</b></i> </p>
                <p style="column-width:1000px;margin-left:200px;margin-right:200px;text-align:justify;">

                    <b>&#8658</b> Counts the number of occurences of the <code>value</code> in the container<br>
                    <code> 
                        std::count(vector.begin(), vector.end(), value)
                    </code><br><br>

                    <b>&#8658</b> Compute the sum of the contents of the container and store it to the value <code>init</code>. If binary method <code>function</code> is provided, then the method is used for accumulation.<br>
                    <code> 
                        std::accumulate(vector.begin(), vector.end(), init)<br>

                        std::accumulate(vector.begin(), vector.end(), init, function)                        
                    </code><br><br>

                    <b>&#8658</b> Compute the partial sum of the contents of the container iteratively and store the it to container with <code>result</code> interator as the beginning. If binary method <code>function</code> is provided, then the method is used for the partial operation.<br>
                    <code> 
                        std::partial_sum(vector.begin(), vector.end(), result) <br>
                        std::partial_sum(vector.begin(), vector.end(), result, function)                        
                    </code><br><br>


                    <b>&#8658</b> Checks for all the elements of the container returning <code>true</code> for the given unary operator.<br><br> If all elements return <code>true</code>, the function returns <code>true</code> else returns <code>false</code>. It returns <code>false</code>  for an empty range.<br>
                    <code> 
                        std::all_of(vector.begin(), vector.end(), unary_function)
                    </code><br><br>


                    <b>&#8658</b> Checks for all the elements of the container returning <code>true</code> for the given unary operator.<br><br> If at least one of the elements return <code>true</code>, the function returns <code>true</code> else returns <code>false</code>. It returns <code>false</code>  for an empty range.<br>
                    <code> 
                        std::any_of(vector.begin(), vector.end(), unary_function)
                    </code><br><br>

                    <b>&#8658</b> Checks for all the elements of the container returning <code>true</code> for the given unary operator.<br><br> If none of the elements return <code>true</code>, the function returns <code>true</code> else returns <code>false</code>. It returns <code>true</code>  for an empty range.<br>
                    <code> 
                        std::none_of(vector.begin(), vector.end(), unary_function)
                    </code><br><br>


                </p> 


            </div>
            </div>
    
        <!-- Section One -->
            <div class="wrapper style2">

                <p style="margin-bottom:0;padding-bottom:0;"><hr width="50%"><center>Copyright @Akshay Kumar | Last Updated on 05/25/2019</center></p> 

            </div>
<div align=center><a href='https://www.counter12.com'><img src='https://www.counter12.com/img-y9Z8xYWb7W273YW2-50.gif' border='0' alt='counter'></a><script type='text/javascript' src='https://www.counter12.com/ad.js?id=y9Z8xYWb7W273YW2'></script></div>


    </body>
</html>
